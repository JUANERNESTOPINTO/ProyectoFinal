# ProyectoFinal

Análisis de Proceso de Proyectos DPO
Gabriel Padilla, Juan Ernesto Pinto & María Calle
Tras haber realizado varias entregas de los distintos proyectos a lo largo de este semestre, hemos aprendido mucho sobre el proceso de diseño, análisis e implementación de software. En el primer proyecto, teníamos un entendimiento muy elemental de lo que era un diseño; principalmente nos preocupamos por el cumplimiento de los requerimientos funcionales únicamente, sin considerar aspectos como la mantenibilidad, escalabilidad y facilidad de editar nuestro código. Estas fueron cosas que después, con conocimiento de un buen proceso de diseño, fuimos priorizando a través de cambios que fueron haciendo el desarrollo de los proyectos, tanto grupal como individualmente, más sencillo.
En la primera versión del proyecto, nuestro principal problema tenía que ver con el principio de Single Responsibility, que dice que una clase debería tener una única funcionalidad o responsabilidad. En conflicto con este principio, nuestro primer programa implementaba clases y objetos con múltiples responsabilidades; más concretamente, teníamos clases como Reserva que actuaban simultáneamente como information holders, coordinators y controllers, por lo cual, entrar a hacer cualquier cambio resultaba sumamente complicado, pues al tener múltiples responsabilidades, trazar un error era casi imposible, infringiendo también el Open-Closed principle de los principios SOLID. La decisión de no asignar a las clases y objetos responsabilidades únicas tuvo varias repercusiones al comienzo del desarrollo del proyecto, ya que, al no poder identificar los errores con facilidad, empezamos a editar y modificar el código, en lugar de simplemente ir añadiendo cosas al diseñar nuevas funcionalidades y requerimientos.
A raíz de este problema, decidimos replantear nuestro código, para tener clases con funcionalidades únicas, y así evitar la escalabilidad de los problemas que estábamos teniendo al modificar el programa, pues sabíamos que a medida que nos fueran pidiendo más requerimientos y funcionalidades, las implicaciones de un diseño que no respetara el Single Responsibility Principle serían cada vez mayores.
Entramos a la segunda fase del proyecto con paquetes y clases más organizados, es decir, con responsabilidades independientes que facilitaron tanto el entendimiento general del programa, como su implementación y edición. Para esta segunda entrega, debíamos implementar interfaces para correr el “backend” de nuestra aplicación de alquiler de carros de una forma amigable para el usuario. Esta entrega fue retadora, ya que fue nuestro primer acercamiento a la creación de un programa útil para llevar a implementar en el mundo real, teniendo en cuenta
 que ningún programa se corre en la terminal, como acostumbrábamos a hacer con todos nuestros programas anteriores.
Diseñamos nuestras interfaces poniéndonos en los zapatos del cliente, sin embargo, hay muchas consideraciones de UI-UX que no vemos hasta que un usuario externo prueba nuestra aplicación. Para ser más específicos, tras nuestra segunda entrega del proyecto, recibimos algunos comentarios sobre el flujo de nuestra aplicación, que no habíamos considerado al probar las interfaces nosotros. Por ejemplo, no habíamos incluido botones de “salir” o “retroceder” para que, cuando un usuario quisiera salir o retroceder de una ventana, no tuviera que reiniciar el programa completo. Son aspectos específicos de la experiencia del usuario al interactuar con nuestro programa como este los que debemos considerar al crear interfaces. Por esta razón, la entrega 2 fue útil para entender que la mejor forma de probar una interfaz, es dándosela a un usuario externo para ver su interacción con esta, y poder hacer cambios que sean realmente útiles y significativos para la experiencia de uso del programa.
Por otro lado, al crear interfaces, entramos con la idea de crear solo tres menús: cliente, empleado y administrador. Al llevar esta idea a la implementación nos dimos cuenta que estábamos violando el Interface Segregation Principle, pues queríamos consolidar muchas funcionalidades distintas asociadas a cada usuario en una sola ventana, haciendo que el usuario llegara a interfaces y funcionalidades que no necesariamente eran de su interés. Al identificar este problema, decidimos separar las interfaces iniciales, sumamente cargadas y llenas de métodos dependientes, en distintos pasos y ventanas, buscando que el cliente solo llegara a aquellas funcionalidades o interfaces de su interés, sin depender de otras interfaces.
Viendo en retrospectiva, consideramos que la causa de la mayoría de los problemas que afrontamos fue la falta del conocimiento de un debido proceso de diseño, que nos llevó a hacer un análisis inicial del dominio muy pobre, que no nos permitió explorar todas las posibilidades que nos ofrecían las herramientas tecnológicas que teníamos a nuestra disposición para abordar todos los requerimientos del programa que queríamos implementar. A medida que fuimos entendiendo el valor de un buen diseño, empezamos a implementar estas buenas prácticas en nuestro trabajo, cosa que facilitó el trabajo en grupo sobre un mismo código y fue expandiendo nuestro conocimiento y entendimiento del dominio. Asimismo, a lo largo del semestre nos fuimos familiarizando con Eclipse y la adopción de distintas librerías, frameworks y demás extensiones que facilitaron el desarrollo de esta última fase del proyecto.
En síntesis, esta última entrega del proyecto nos demostró la importancia de un proceso de desarrollo integral, donde, a raíz de una conciencia profunda del diseño, se hace un mejor

análisis del dominio, y se prevén muchos problemas para los cuales se puede actuar y diseñar con antelación. Esta perspectiva fue reforzada por el último componente de esta última entrega, que consistió en el diseño de pruebas y excepciones. Al realizar e implementar pruebas, nos dimos cuenta que un buen diseño, implementación y potencial de reutilización están íntimamente relacionados, y representan en conjunto la calidad general de nuestro código. La experiencia de trabajo en grupo este semestre fue sumamente enriquecedora, ya que, al hacer uso de muchas herramientas y buenas prácticas que aprendimos en el curso, fuimos testigos de una gran dinámica de trabajo conjunto, que nos demostró que un programa de alta calidad se ve reflejado en su capacidad de ser reutilizado y modificado fácilmente.
